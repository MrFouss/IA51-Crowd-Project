/** 
 * MIT License
 * 
 * Copyright (c) 2017 Fouss
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package fr.utbm.info.ia51.crowdproject.^agent

import fr.utbm.info.ia51.crowdproject.environment.AgentBody
import fr.utbm.info.ia51.crowdproject.environment.EnvironmentBody
import fr.utbm.info.ia51.crowdproject.environment.StaticBody
import fr.utbm.info.ia51.crowdproject.motion.MotionBehavior
import fr.utbm.info.ia51.crowdproject.motion.MotionQuery
import fr.utbm.info.ia51.crowdproject.ui.FXMLViewerController
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.util.OpenEventSpace
import java.awt.Color
import java.util.ArrayList
import java.util.LinkedList
import java.util.Random
import java.util.TreeMap
import java.util.UUID
import org.dyn4j.geometry.Geometry
import org.dyn4j.geometry.Vector2
import fr.utbm.info.ia51.crowdproject.environment.SoundSource
import org.dyn4j.dynamics.Body

/**
 * The environment agent, managing all the other agents
 */
agent Environment {
	
	uses Logging, Lifecycle, DefaultContextInteractions, EnvironmentManager, EnvironmentFrontEnd

	val agentBodies = new TreeMap<UUID, AgentBody>
	val staticBodies = new LinkedList<StaticBody>
	val soundSources = new LinkedList<SoundSource>
	
	val actions = new LinkedList<MotionQuery>
	var targetPosition : Vector2

	var motionBehavior : MotionBehavior
	var time = 0 as long
	val random = new Random

	on Initialize {

		var width = occurrence.parameters.get(0) as Float
		var height = occurrence.parameters.get(1) as Float
		var nbHamsters = occurrence.parameters.get(2) as Integer
		var perceptionDistance = occurrence.parameters.get(3) as Float
		motionBehavior = occurrence.parameters.get(4) as MotionBehavior
		var controller = occurrence.parameters.get(5) as FXMLViewerController

		// Communication from environment to UI
		(defaultSpace as OpenEventSpace).register(controller)
		// Communication from UI to environment
		controller.openSpace = defaultSpace as OpenEventSpace

		info("Beginning of the simulation. Spawning the environment agent.")

		setSkill(new DefaultEnvironmentManager(width, height), typeof(EnvironmentManager))
		setSkill(new DefaultEnvironmentFrontEnd, typeof(EnvironmentFrontEnd))
		
		initializeStaticBodies(width, height)
		
		var actionsList = new ArrayList
		
		// Spawn hamsters
		for (i : 0 ..< nbHamsters) {
			var isDeaf = random.nextBoolean
			var agentBody = createHamster(motionBehavior, if (isDeaf) perceptionDistance else 0, isDeaf)
			agentBodies.put(agentBody.agentId, agentBody)
			var params = new ArrayList<Object>
			params += #[agentBody.agentId, motionBehavior]
			spawnInContextWithID(typeof(Hamster), agentBody.agentId, defaultContext, params)
		}
		
		info("Number of bodies in the world: " + world.bodyCount)
		
		val totalListOfBodies = new ArrayList<Body>
		totalListOfBodies += agentBodies.values
		totalListOfBodies += staticBodies
		totalListOfBodies += soundSources
		emit(new FrontEndEnvironmentInitialization(totalListOfBodies))
		
		emit(new RunBeginningOfStep) [it.isMe]
	}

	on Destroy {
		info("End of the simulation. Killing the environment agent.")
	}

	on RunBeginningOfStep {
		synchronized (this) {

			for (e : getPerceptions(agentBodies.values).entrySet) {
				val agentId = e.key.agentId
				sendPerceptions(agentId, e.key, this.time, e.value)
			}
		}
	}
	
	on Action [occurrence.time >= this.time] {
		synchronized (this) {
			this.actions += occurrence.motion
			
			if (this.actions.size == this.agentBodies.size) {
				val actionsToApply = new LinkedList(actions)
				this.actions.clear
				emit(new RunEndOfStep(actionsToApply)) [it.isMe]
			}
		}
	}

	on RunEndOfStep {
		synchronized (this) {
			// Eventually take into account the actions of the player
			// actions += ...
			
			// Change the state of the universe
			applyActions(occurrence.actionsToApply, this.agentBodies)

			updateEnvironment

			if (isTargetReached(agentBodies.values, targetPosition)) {
				// TODO do something to notify that all hamsters reached the target
				killMe
			}
			
			// Informs the view that a front end update is needed
			val bodiesToVisuallyUpdate = new ArrayList<Body>()
			bodiesToVisuallyUpdate += (agentBodies.values)
			bodiesToVisuallyUpdate += soundSources
			emit(new FrontEndEnvironmentChange(new ArrayList(agentBodies.values)))
			Thread.sleep(100/6)
			
			// Increase time value
			time++

			// Move to next step
			emit(new RunBeginningOfStep) [it.isMe]
		}
	}

	on EndOfSimulation {
		killMe
	}
	
	private def initializeStaticBodies(width : float, height : float) {
		
		// Spawn top wall
		val topWall = new StaticBody(Geometry.createRectangle(width, 6), Color.GRAY)
		topWall.getFixture(0).setRestitution(0.5)
		topWall.translate(0, -height/2 + 3)
		world.addBody(topWall)
		this.staticBodies += topWall

		// Spawn bottom wall
		val bottomWall = new StaticBody(Geometry.createRectangle(width, 6), Color.GRAY)
		bottomWall.getFixture(0).setRestitution(0.5)
		bottomWall.translate(0, height / 2 - 3)
		world.addBody(bottomWall)
		this.staticBodies += bottomWall

		// Spawn left wall
		val leftWall = new StaticBody(Geometry.createRectangle(6, height), Color.GRAY)
		leftWall.getFixture(0).setRestitution(0.5)
		leftWall.translate(-width/2 + 3, 0)
		world.addBody(leftWall)
		this.staticBodies += leftWall

		// Spawn right wall
		val rightWall = new StaticBody(Geometry.createRectangle(6, height), Color.GRAY)
		rightWall.getFixture(0).setRestitution(0.5)
		rightWall.translate(width/2 - 3, 0)
		world.addBody(rightWall)
		this.staticBodies += rightWall
	}
}
