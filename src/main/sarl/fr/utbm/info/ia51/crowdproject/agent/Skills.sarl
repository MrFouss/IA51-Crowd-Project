/** 
 * MIT License
 * 
 * Copyright (c) 2017 Fouss
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package fr.utbm.info.ia51.crowdproject.^agent

import java.util.List
import java.util.Map
import fr.utbm.info.ia51.crowdproject.environment.AgentBody
import org.dyn4j.geometry.Vector2
import java.util.TreeMap
import org.dyn4j.dynamics.World
import fr.utbm.info.ia51.crowdproject.environment.MobileBody
import fr.utbm.info.ia51.crowdproject.environment.EnvironmentBody
import java.util.LinkedList
import org.dyn4j.geometry.Geometry
import java.util.UUID
import fr.utbm.info.ia51.crowdproject.environment.HamsterBody
import org.dyn4j.collision.AxisAlignedBounds
import io.sarl.core.DefaultContextInteractions
import io.sarl.lang.core.Address
import fr.utbm.info.ia51.crowdproject.motion.MotionQuery
import java.util.Collection

/** 
 * Default implementation of the EnvironmentManager capacity
 */
skill DefaultEnvironmentManager implements EnvironmentManager {

	val UPDATE_TIME = 0.1f

	var world : World

	new (width : float, height : float) {
		this.world = new World()
		world.setBounds(new AxisAlignedBounds(width, height))
	}
	
	/** 
	 * Creates a hamster's body in the world
	 * 
	 * @param perceptionDistance the distance of perception of the hamster
	 * @param isDeaf <code>true if the hamster can't have any audio perception</code>
	 */
	def createHamster(perceptionDistance : float, isDeaf : boolean) : HamsterBody {
		val body = new HamsterBody(Geometry.createCircle(1.0f),
			perceptionDistance,
			isDeaf,
			UUID::randomUUID)
		this.world.addBody(body);
		return body
	}
	
	/** 
	 * Apply the list of actions
	 * 
	 * @param actions the list of actions to apply
	 * @param agentBodies the list of agent bodies
	 */
	def applyActions(actions : List<MotionQuery>, agentBodies : Map<UUID, AgentBody>) {
		for (action : actions) {
			var agentBody = agentBodies.get(action.emitter)
			
			// TODO apply all actions
		}
	}
	
	/** 
	 * Checks if the target has been reached for all agents
	 * 
	 * @param agentBodies the list of all agent bodies
	 * @param targetPosition current position of the target
	 * @return <code>true</code> if all agents reached the target, <code>false</code> otherwise 
	 */
	def isTargetReached(agentBodies : Collection<AgentBody>, targetPosition : Vector2) : boolean {
		return false
//		for (body : agentBodies) {
//			// TODO if any agent's body isn't within a certain range of the target, return false
//		}
//		return true
	}
	
	/** 
	 * Replies the overall perceptions of each agent
	 * 
	 * @param agentBodies the list of all agent bodies
	 * @return the list of perceptions for each agent's body
	 */
	def getPerceptions(agentBodies : Collection<AgentBody>) : Map<AgentBody, List<EnvironmentBody>> {
		var perceptions = new TreeMap<AgentBody, List<EnvironmentBody>>
		for (agentBody : agentBodies) {
			val perceivedObjects = new LinkedList<EnvironmentBody>
			perceivedObjects += getVisualPerceptions(agentBody) + getAuditoryPerceptions(agentBody)
			perceptions.put(agentBody, perceivedObjects)
		}
		return perceptions
	}
	
	/** 
	 * Replies the visual perceptions of the agent
	 * 
	 * @param agentBody the body that perceives its environment
	 * @return the list of visual perceptions for the agent's body
	 */
	def getVisualPerceptions(agentBody : AgentBody) : List<EnvironmentBody> {
		val perceivedObjects = new LinkedList<EnvironmentBody>

		// TODO compute visual perceptions for the body
		
		return perceivedObjects
	}
	
	/** 
	 * Replies the auditory perceptions of the agent
	 * 
	 * @param agentBody the body that perceives its environment
	 * @return the list of auditory perceptions for the agent's body
	 */
	def getAuditoryPerceptions(agentBody : AgentBody) : List<EnvironmentBody> {
		val perceivedObjects = new LinkedList<EnvironmentBody>

		// TODO compute auditory perceptions for the body
		
		return perceivedObjects
	}
	
	/** 
	 * Moves an object in a direction
	 * 
	 * @param object the object to move
	 * @param motion data about the path the path to follow
	 */
	def moveObject(object : MobileBody, motion : MotionQuery) {
		// TODO
	}
	
	/** 
	 * Updates the physical state of the environment
	 */
	def updateEnvironment {
		world.update(UPDATE_TIME)
	}
}

skill DefaultEnvironmentFrontEnd implements EnvironmentFrontEnd {
	
	uses DefaultContextInteractions
	
	/**
	 * Sends a list of perceived objects to an agent
	 * 
	 * @param agentId the identifier of the agent
	 * @param time the time at which the perception is sent
	 * @param perceivedObjects the list of perceived objects
	 * @param position current position of the agent's body
	 * @param orientation current orientation the agent's body is facing
	 */
	def sendPerceptions(agentId : UUID, time : long, perceivedObjects : List<EnvironmentBody>, position : Vector2, orientation : double) {
		emit(new Perception(agentId, time, perceivedObjects, position, orientation))
			[it == new Address(defaultSpace.spaceID, agentId)]
	}
}

/** 
 * Default implementation of the EnvironmentMotion capacity
 */
skill DefaultEnvironmentMotion implements EnvironmentMotion {
	
	uses DefaultContextInteractions
	/** 
	 * Sends the environment a message, asking to be moved
	 * 
	 * @param agentId identifier of the agent to move
	 * @param environmentAddress the address the motion query must be sent
	 * @param time the time at which the movement query is sent
	 * @param motion data about the path to follow
	 */
	def move(agentId : UUID, environmentAddress : Address, time : long, motion : MotionQuery) {
		emit(new Action(agentId, time, motion))
			[it == environmentAddress]
	}
}
