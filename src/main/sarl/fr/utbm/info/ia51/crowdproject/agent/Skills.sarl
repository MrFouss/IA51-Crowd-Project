/** 
 * MIT License
 * 
 * Copyright (c) 2017 Fouss
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package fr.utbm.info.ia51.crowdproject.^agent

import fr.utbm.info.ia51.crowdproject.environment.AgentBody
import fr.utbm.info.ia51.crowdproject.environment.EnvironmentBody
import fr.utbm.info.ia51.crowdproject.environment.HamsterBody
import fr.utbm.info.ia51.crowdproject.motion.MotionQuery
import io.sarl.core.DefaultContextInteractions
import io.sarl.lang.core.Address
import java.util.Collection
import java.util.LinkedList
import java.util.List
import java.util.Map
import java.util.TreeMap
import java.util.UUID
import org.dyn4j.collision.AxisAlignedBounds
import org.dyn4j.dynamics.World
import org.dyn4j.geometry.Geometry
import org.dyn4j.geometry.Vector2
import fr.utbm.info.ia51.crowdproject.motion.MotionBehavior
import org.dyn4j.dynamics.CollisionAdapter
import org.dyn4j.dynamics.Body
import org.dyn4j.dynamics.BodyFixture
import org.dyn4j.collision.manifold.Manifold
import java.util.ArrayList
import org.dyn4j.collision.Fixture
import org.dyn4j.dynamics.StepAdapter
import org.dyn4j.dynamics.Step

/** 
 * Default implementation of the EnvironmentManager capacity
 */
skill DefaultEnvironmentManager implements EnvironmentManager {
	
	val DISTANCE_TO_TARGET = 10.0f;

	var world : World
	var lastNanoTime : long
	var viewedBodies : TreeMap<EnvironmentBody, LinkedList<EnvironmentBody>>

	new (width : float, height : float) {
		this.world = new World()
		this.world.gravity = World.ZERO_GRAVITY
		this.world.settings.stepFrequency = 1.0f/60.0f
		this.world.setBounds(new AxisAlignedBounds(width, height))
		lastNanoTime = System.nanoTime()
		viewedBodies = new TreeMap<EnvironmentBody, LinkedList<EnvironmentBody>>
		this.world.addListener(new StepAdapter() {
			//  At the beginning of a step, we clear the list of view bodies
			override begin(step : Step, world : World) {
				viewedBodies.clear	
			}
		})
		this.world.addListener(new CollisionAdapter() {
			/* When the frustrum of an object intersect with an other object,
			 it is added to the perceptions list */
			override collision(body1 : Body, fixture1 : BodyFixture,
				body2 : Body, fixture2 : BodyFixture, manifold : Manifold
			) : boolean {
				var seer : EnvironmentBody
				var seen : EnvironmentBody
				// We consider only bodies defined as EnvironmentBody
				if (!EnvironmentBody.isInstance(body1) ||
					 !EnvironmentBody.isInstance(body2)) {
					return true
				}
				// Checking if one fixture is a frustrum, and if yes wish one
				if (fixture1.sensor) {
					// We don't want frustrums to see other frustrums
					if (fixture2.sensor) {
						return false
					}
					seer = body1 as EnvironmentBody
					seen = body2 as EnvironmentBody
				} else if (fixture2.sensor) {
					seer = body2 as EnvironmentBody
					seen = body1 as EnvironmentBody
				} else {
					// If none of them is a frustrum, normal collisions have to be applied
					return true
				}
				// checking if the body already perceived an other body and adding the new one
				var bodyList = viewedBodies.get(seer)
				if (bodyList === null) {
					bodyList = new LinkedList<EnvironmentBody>()
					viewedBodies.put(seer, bodyList)
				}
				bodyList.add(seen)
				return false;
			}
		})
	}
	
	/** 
	 * Creates a hamster's body in the world
	 * 
	 * @param motionBehavior the world's motion behavior
	 * @param frustrumRadius the distance of perception of the hamster
	 * @param frustrumAngle the radius of the frustrum of the hamster
	 * @param isDeaf <code>true if the hamster can't have any audio perception</code>
	 */
	def createHamster(motionBehavior : MotionBehavior,
		frustrumRadius : float,
		frustrumAngle : float,
		isDeaf : boolean
	) : HamsterBody {
		val body = new HamsterBody(
			Geometry.createCircle(5.0f),
			Geometry.createSlice(frustrumRadius, frustrumAngle),
			isDeaf,
			UUID::randomUUID,
			motionBehavior
		)
		body.translate(Math.random * 600 - 300, Math.random * 400 - 200)
		body.rotateAboutCenter(Math.random * Math.PI * 2)
		this.world.addBody(body);
		return body
	}
	
	/** 
	 * Apply the list of actions
	 * 
	 * @param actions the list of actions to apply
	 * @param agentBodies the list of agent bodies
	 */
	def applyActions(actions : List<MotionQuery>, agentBodies : Map<UUID, AgentBody>) {
		for (action : actions) {
			var agentBody = agentBodies.get(action.emitter)
			
			if(agentBody.motionBehavior == MotionBehavior::KINEMATIC) {
				agentBody.setLinearVelocity(action.linear)
				agentBody.setAngularVelocity(action.angular)
			} else if (agentBody.motionBehavior == MotionBehavior::STEERING) {
				agentBody.applyForce(action.linear)
				agentBody.applyTorque(action.angular)
			} else {
				throw new EnumConstantNotPresentException(MotionBehavior, "")
			}
		}
	}
	
	/** 
	 * Checks if the target has been reached for all agents
	 * 
	 * @param agentBodies the list of all agent bodies
	 * @param targetPosition current position of the target
	 * @return <code>true</code> if all agents reached the target, <code>false</code> otherwise 
	 */
	def isTargetReached(agentBodies : Collection<AgentBody>, targetPosition : Vector2) : boolean {
//		for (body : agentBodies) {
//			if (body.position.to(targetPosition).magnitude > DISTANCE_TO_TARGET)
//				return false
//		}
//		return true
		return false
	}
	
	/** 
	 * Replies the overall perceptions of each agent
	 * 
	 * @param agentBodies the list of all agent bodies
	 * @return the list of perceptions for each agent's body
	 */
	def getPerceptions(agentBodies : Collection<AgentBody>) : Map<AgentBody, List<EnvironmentBody>> {
		var perceptions = new TreeMap<AgentBody, List<EnvironmentBody>>
		for (agentBody : agentBodies) {
			val perceivedObjects = new LinkedList<EnvironmentBody>
			perceivedObjects += getVisualPerceptions(agentBody) + getAuditoryPerceptions(agentBody)
			perceptions.put(agentBody, perceivedObjects)
		}
		return perceptions
	}
	
	/** 
	 * Replies the visual perceptions of the agent
	 * 
	 * @param agentBody the body that perceives its environment
	 * @return the list of visual perceptions for the agent's body
	 */
	def getVisualPerceptions(agentBody : AgentBody) : List<EnvironmentBody> {
		val perceivedObjects = new LinkedList<EnvironmentBody>

		if (agentBody.deaf) {
			val seens = viewedBodies.get(agentBody)
			if (seens !== null) {
				perceivedObjects.addAll(seens)				
			}
		}
		
		return perceivedObjects
	}
	
	/** 
	 * Replies the auditory perceptions of the agent
	 * 
	 * @param agentBody the body that perceives its environment
	 * @return the list of auditory perceptions for the agent's body
	 */
	def getAuditoryPerceptions(agentBody : AgentBody) : List<EnvironmentBody> {
		val perceivedObjects = new LinkedList<EnvironmentBody>

		// TODO compute auditory perceptions for the body
		
		return perceivedObjects
	}

	/** 
	 * Updates the physical state of the environment
	 */
	def updateEnvironment {
		val thisNanoTime = System.nanoTime
		val timeDiff = thisNanoTime - this.lastNanoTime
		this.lastNanoTime = thisNanoTime
		world.update(timeDiff / 1.0e9)
	}

	/**
	 * Getter of the world
	 * 
	 * @return the world instance
	 */
	def getWorld : World {
		return this.world
	}
}

skill DefaultEnvironmentFrontEnd implements EnvironmentFrontEnd {
	
	uses DefaultContextInteractions
	
	/**
	 * Sends a list of perceived objects to an agent
	 * 
	 * @param agentId the identifier of the agent
	 * @param agentBody the agent's body
	 * @param time the time at which the perception is sent
	 * @param perceivedObjects the list of perceived objects
	 */
	def sendPerceptions(agentId : UUID, agentBody : AgentBody, time : long, perceivedObjects : List<EnvironmentBody>) {
		emit(new Perception(agentId, agentBody, time, perceivedObjects))
			[it == new Address(defaultSpace.spaceID, agentId)]
	}
}

/** 
 * Default implementation of the EnvironmentMotion capacity
 */
skill DefaultEnvironmentMotion implements EnvironmentMotion {
	
	uses DefaultContextInteractions
	
	/** 
	 * Sends the environment a message, asking to be moved
	 * 
	 * @param agentId identifier of the agent to move
	 * @param environmentAddress the address the motion query must be sent
	 * @param time the time at which the movement query is sent
	 * @param motion data about the path to follow
	 */
	def move(agentId : UUID, environmentAddress : Address, time : long, motion : MotionQuery) {
		emit(new Action(agentId, time, motion))
			[it == environmentAddress]
	}
}
