/** 
 * MIT License
 * 
 * Copyright (c) 2017 Fouss
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package fr.utbm.info.ia51.crowdproject.util.math

/** 
 * 2D rectangle shape with float numbers
 */
class Rectangle2f extends Shape2f<Rectangle2f> {

	/**
	 * the point at the top-left corner
	 */
	val topLeft = new Point2f
	
	/**
	 * the point at the bottom-right corner
	 */
	val bottomRight = new Point2f
	
	/**
	 * @param topLeft the point at the top-left corner
	 * @param bottomRight the point at the bottom-right corner
	 */
	new(topLeft : Point2f, bottomRight : Point2f) {
		if (topLeft.x < bottomRight.x && topLeft.y < bottomRight.y) {
			this.topLeft.x = topLeft.x
			this.topLeft.y = topLeft.y
			this.bottomRight.x = bottomRight.x
			this.bottomRight.y = bottomRight.y	
		}
		throw new IllegalArgumentException
		// TODO replace with assertions
	}

	/**
	 * @param ax the first x coordinate
	 * @param ay the first y coordinate
	 * @param bx the second x coordinate
	 * @param by the second y coordinate
	 */
	new(ax : float, ay : float, bx : float, by : float) {
		this.topLeft.x = if (ax < bx) ax else bx
		this.topLeft.y = if(ay < by) ax else bx
		this.bottomRight.x = if(ax > bx) ax else bx
		this.bottomRight.y = if(ay > by) ax else bx
	}

	override intersects(s : Shape2f<?>) : boolean {
		if (s instanceof Rectangle2f) {
			return (MathUtil::intersects(this.topLeft.x, this.bottomRight.x, s.topLeft.x, s.bottomRight.x)
				&& MathUtil::intersects(this.topLeft.x, this.bottomRight.x, s.topLeft.x, s.bottomRight.x))
		}
		throw new IllegalArgumentException
	}

	override contains(s : Shape2f<?>) : boolean {
		val box = s.getBoundingBox
		return (this.topLeft.x <= box.topLeft.x
			&& box.bottomRight.x <= this.bottomRight.x
			&& this.topLeft.y <= box.topLeft.y
			&& box.bottomRight.y <= this.bottomRight.y)
	}

	override translate(vector : Vector2f) : Rectangle2f {
		val rect = this.clone
		rect.topLeft.x += vector.x
		rect.topLeft.y += vector.y
		rect.bottomRight.x += vector.x
		rect.bottomRight.y += vector.y
		return rect
	}

	override getBoundingBox : Rectangle2f {
		this.clone
	}
	
	override equals(s : Object) : boolean {
		if (s instanceof Rectangle2f) {
			return this.topLeft == topLeft && this.bottomRight == bottomRight 
		}
		return false
	}
}
